**根据定义推出递推公式，根据递推公式得到遍历顺序，根据遍历顺序得到base case**

动态规划

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //coins  1 2 5
        //i      0 1 2 3 4 5
        //dp[i]  0 1 1 2 2 
        vector<int> dp(amount+1,amount+1);
        dp[0] = 0;

        for (int i = 1; i <= amount; i++){

            for (int j = 0; j < coins.size(); j++){
                if (coins[j] > i) continue;
                dp[i] = min(dp[i], dp[i-coins[j]]+1);
            }
        }

        if (dp[amount] == amount+1){
            return -1;
        }else{
            return dp[amount];
        }

    }
};
```

01背包

```c++
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    //i表示第i个物品
    //dp[i][j] =
    //  dp[i-1][j] + dp[i][j-weight[i]];
  	//dp[i][j]: 总容量为j，使用前i个物品，有多少种选择
    vector<int> weight;
    weight.push_back(0);
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        int temp;
        scanf("%d", &temp);
        weight.push_back(temp);
    }

    int dp[21][41];//0--20, 0--40
    for (int i = 0; i < 21; i++) {
        for (int j = 0; j < 41; j++) {
            dp[i][j] = 0;
        }
    }
    for (int i = 0; i < 21; ++i) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= n; i++) {//i是第i个
        for (int j = 1; j <= 40; j++) {
            if (j - weight[i] < 0) {
                dp[i][j] = dp[i-1][j];
                continue;
            }
            dp[i][j] = dp[i-1][j] + dp[i-1][j-weight[i]];
        }
    }
    printf("%d\n",dp[n][40]);
    return 0;
}
```

完全背包

```c++
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;

int main() {
    //i表示第i个物品
    //dp[i][j] =
    //  dp[i-1][j] + dp[i][j-weight[i]];
  	//dp[i][j]: 总容量为j，使用前i个物品，有多少种选择
    vector<int> weight;
    weight.push_back(0);
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        int temp;
        scanf("%d", &temp);
        weight.push_back(temp);
    }

    int dp[21][41];//0--20, 0--40
    for (int i = 0; i < 21; i++) {
        for (int j = 0; j < 41; j++) {
            dp[i][j] = 0;
        }
    }
    for (int i = 0; i < 21; ++i) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= n; i++) {//i是第i个
        for (int j = 1; j <= 40; j++) {
            if (j - weight[i] < 0) {
                dp[i][j] = dp[i-1][j];
                continue;
            }
          	// 区别在于dp[i][j-weight[i]]，是可以使用第i个物品的
            dp[i][j] = dp[i-1][j] + dp[i][j-weight[i]];
        }
    }
    printf("%d\n",dp[n][40]);
    return 0;
}
```

最长子序列

```c++
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    scanf("%d", &n);
    vector<int> m;
    for (int i = 0; i < n; i++) {
        int temp; scanf("%d", &temp); m.push_back(temp);
    }

     vector<int> dp(n, 1)
      for (int i = 1; i < n; i++) {// dp
          for (int j = i - 1; j >= 0; j--) {
              if (m[j] < m[i]) {
                  dp[i] = max(dp[i], dp[j] + 1);
               }
           }
      }
}
```

凑零钱

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //coins  1 2 5
        //i      0 1 2 3 4 5
        //dp[i]  0 1 1 2 2 
        vector<int> dp(amount+1,amount+1);
        // dp[i] 凑出i块钱最少需要多少个硬币
        dp[0] = 0;

        for (int i = 1; i <= amount; i++){

            for (int j = 0; j < coins.size(); j++){
                if (coins[j] > i) continue;
                dp[i] = min(dp[i], dp[i-coins[j]]+1);
            }
        }

        if (dp[amount] == amount+1){
            return -1;
        }else{
            return dp[amount];
        }

    }
};
```

