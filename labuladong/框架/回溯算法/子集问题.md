## 1.元素 无重复，不可复选
```c++
// 通过控制起始坐标以去重
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    void traverse(vector<int>& nums, int start){
        
        //
        ans.push_back(path);

        for (int idx = start; idx < nums.size(); ++idx) {
            //
            path.push_back(nums[idx]);
            traverse(nums, idx+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        traverse(nums, 0);
        return ans;
    }
};
```
---
## 2.元素 无重复，可复选
```c++
// 通过控制起始坐标以去重
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    int pathSum = 0;
    void traverse(vector<int>& candidates, int target, int start){

        //
        if (pathSum == target){
            ans.push_back(path);
            return;
        }
        if (pathSum > target) return;

        for (int idx = start; idx < candidates.size(); ++idx) {
            //
            path.push_back(candidates[idx]);
            pathSum += candidates[idx];
            traverse(candidates, target, idx);
            pathSum -= candidates[idx];
            path.pop_back();
        }
        
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        traverse(candidates, target, 0);
        return ans;
    }
};
```
---
## 2.元素 重复，不可复选
```c++
// 通过控制起始坐标以去重，排序使得相同元素相邻，剪掉相同的树枝
// 因为是通过控制起始坐标来去重，所以只是判断剪去同一节点的相同树枝是不能实现去重的
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    
    void traverse(vector<int>& nums, int start){

        //
        ans.push_back(path);

        for (int idx = start; idx < nums.size(); ++idx) {
            //
            if (idx > start && nums[idx] == nums[idx-1]) continue;
            path.push_back(nums[idx]);
            traverse(nums, idx+1);
            path.pop_back();
        }
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        traverse(nums, 0);
        return ans;
    }
};
```
