## 1.元素 无重复，不可复选
```c++
// 通过控制起始坐标以去重
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    void traverse(vector<int>& nums, int start){
        
        //
        ans.push_back(path);

        for (int idx = start; idx < nums.size(); ++idx) {
            //
            path.push_back(nums[idx]);
            traverse(nums, idx+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        traverse(nums, 0);
        return ans;
    }
};
```
---
## 2.元素 无重复，可复选
```c++
// 通过控制起始坐标以去重
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    int pathSum = 0;
    void traverse(vector<int>& candidates, int target, int start){

        //
        if (pathSum == target){
            ans.push_back(path);
            return;
        }
        if (pathSum > target) return;

        for (int idx = start; idx < candidates.size(); ++idx) {
            //
            path.push_back(candidates[idx]);
            pathSum += candidates[idx];
            traverse(candidates, target, idx);
            pathSum -= candidates[idx];
            path.pop_back();
        }
        
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        traverse(candidates, target, 0);
        return ans;
    }
};
```
---
## 2.元素 重复，不可复选
```c++
// 通过控制起始坐标以去重，排序使得相同元素相邻，剪掉相同的树枝
// 因为是通过控制起始坐标来去重，所以只是判断剪去同一节点的相同树枝是不能实现去重的
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;
    
    void traverse(vector<int>& nums, int start){// 子集问题，控制起始坐标

        //
        ans.push_back(path);

        set<int> used;
        for (int idx = start; idx < nums.size(); ++idx) {
            // 只是通过used集合剪掉重复树枝是不能实现去重的，举例：7 6 7
            // 会出现[7,6],[6,7]这样的重复子集，所以要排序： 6 7 7
            // 此时，7一定不会出现6的树枝

            // if (idx > start && nums[idx] == nums[idx-1]) continue;
            if (used.count(nums[i]) > 0) continue;// 树枝去重

            used.insert(nums[i]);// 在此循环中，即该根节点的该层只是用一次nums[i]

            path.push_back(nums[idx]);
            traverse(nums, idx+1);
            path.pop_back();
        }
    }
    
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        traverse(nums, 0);
        return ans;
    }
};
```
