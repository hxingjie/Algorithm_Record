# 框架
```c++
// 回溯算法研究的是树枝，树枝上的值就是所做的选择

// 路径：track中的元素
// 选择列表
// 结束条件
void traverse(参数){

    if (结束条件){
        // 更新 res
        return;
    }

    for ( ; ; ) {// for循环中就是树枝
        if (不符合条件) continue;

        path.push_back(选择);// 做选择
        traverse(参数);// 进入下一层决策树
        path.pop_back();// 撤销选择
    }

}
```

子集/组合，使用beg控制选择开始的位置以去重

排列，使用used记录已经使用过的元素或已经使用过的元素的位置以去重

有重复元素的子集/组合，beg + 排序 + 剪掉**相同根**的重复树枝（hasPick记录已经使用过的值（或通过nums[i]==nums[-1]））

有重复元素的排列，used记录track中已经存在的元素的**位置** + 剪掉**相同根**的重复树枝（hasPick记录已经使用过的值）

可复选的子集/组合，下一层决策树的beg是i，而不是i+1

可复选的排列，不使用used记录已经使用过的元素

