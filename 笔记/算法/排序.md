# 排序
https://leetcode.cn/problems/sort-an-array/

## 归并排序

### 归并排序
```c++
class Solution {
public:
    vector<int> tmp;
    void Merge(vector<int>& nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; ++i)
            tmp[i] = nums[i];
        
        // [lo, mid], [mid+1, hi]
        int p1 = lo, p2 = mid+1;
        for (int idx = lo; idx <= hi; ++idx) {
            if (p1 > mid) {
                nums[idx] = tmp[p2++];
            } else if (p2 > hi) {
                nums[idx] = tmp[p1++];
            } else if (tmp[p1] <= tmp[p2]) {
                nums[idx] = tmp[p1++];
            } else if (tmp[p1] > tmp[p2]) {
                nums[idx] = tmp[p2++];
            }
        }
    }
    void MySort(vector<int>& nums, int lo, int hi) {
        if (lo >= hi)
            return;

        int mid = lo + (hi-lo)/2;
        MySort(nums, lo, mid);
        MySort(nums, mid+1, hi);

        Merge(nums, lo, mid, hi);
    }
    vector<int> sortArray(vector<int>& nums) {
        tmp = vector<int>(nums.size(), 0);
        MySort(nums, 0, nums.size()-1);
        return nums;
    }
};
```

### 计算右侧小于当前元素的个数
https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/
```c++
class Solution {
public:
    struct Elem {
        int val, idx;
        Elem() : val(0), idx(-1) {}
        Elem(int _val, int _idx) : val(_val), idx(_idx) {}
    };
    vector<Elem> tmp;
    vector<int> counts;
    void Merge(vector<Elem> &elems, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; ++i)
            tmp[i] = elems[i];
        
        // [lo, mid], [mid+1, hi]
        int p1 = lo, p2 = mid+1;
        for (int idx = lo; idx <= hi; ++idx) {
            if (p1 > mid) {
                elems[idx] = tmp[p2++];
            } else if (p2 > hi) {
                elems[idx] = tmp[p1++];
                counts[elems[idx].idx] += p2-(mid+1); // [mid+1, p2)
            } else if (tmp[p1].val <= tmp[p2].val) {
                elems[idx] = tmp[p1++];
                counts[elems[idx].idx] += p2-(mid+1); // [mid+1, p2)
            } else if (tmp[p1].val > tmp[p2].val) {
                elems[idx] = tmp[p2++];
            }
        }
    }
    void Sort(vector<Elem> &elems, int lo, int hi) {
        if (lo >= hi)
            return;
        int mid = lo + (hi-lo)/2;
        Sort(elems, lo, mid);
        Sort(elems, mid+1, hi);
        Merge(elems, lo, mid, hi);
    }
    vector<int> countSmaller(vector<int>& nums) {
        //tmp = vector<Elem>(nums.size());
        //counts = vector<int>(nums.size());
        tmp.resize(nums.size());
        counts.resize(nums.size());
        vector<Elem> elems;
        for (int i = 0; i < nums.size(); ++i) {
            //elems.push_back(Elem(nums[i], i));
            elems.emplace_back(nums[i], i);
        }
       
        Sort(elems, 0, elems.size()-1);
        return counts;
    }
};
```

### 翻转对
https://leetcode.cn/problems/reverse-pairs/
```c++
class Solution {
public:
    int count;
    vector<int> tmp;
    void Merge(vector<int>& nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; ++i)
            tmp[i] = nums[i];
        
        // [lo, mid], [mid+1, hi] 是有序数组
        int pointer = mid+1; // 用 end 去找目标数
        for (int idx = lo; idx <= mid; ++idx) {
            while (pointer <= hi && static_cast<long long>(tmp[idx]) > static_cast<long long>(tmp[pointer])*2) {
                pointer += 1;
            }
            count += pointer-(mid+1); // [mid+1, end)
        }

        int p1 = lo, p2 = mid+1;
        for (int idx = lo; idx <= hi; ++idx) {
            if (p1 > mid) {
                nums[idx] = tmp[p2++];
            } else if (p2 > hi) {
                nums[idx] = tmp[p1++];
            } else if (tmp[p1] <= tmp[p2]) {
                nums[idx] = tmp[p1++];
            } else if (tmp[p1] > tmp[p2]) {
                nums[idx] = tmp[p2++];
            }
        }
    }
    void MySort(vector<int>& nums, int lo, int hi) {
        if (lo >= hi)
            return;

        int mid = lo + (hi-lo)/2;
        MySort(nums, lo, mid);
        MySort(nums, mid+1, hi);

        Merge(nums, lo, mid, hi);
    }
    int reversePairs(vector<int>& nums) {
        count = 0;
        tmp = vector<int>(nums.size(), 0);
        MySort(nums, 0, nums.size()-1);
        return count;
    }
};
```

## 数组中的逆序对
https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=265&tqId=39249&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D13%26type%3D265&difficulty=undefined&judgeStatus=undefined&tags=&title=
```c++
#include <vector>
class Solution {
public:
    int ans = 0;
    vector<int> tmp;
    void merge(vector<int>& nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) // 复制到辅助数组中
            tmp[i] = nums[i];

        int p1 = lo, p2 = mid+1;
        int idx = lo;
        
        while (p1 <= mid && p2 <= hi) {
            if (tmp[p1] < tmp[p2]){
                ans = (ans+p2-mid-1)%1000000007;
                nums[idx ++] = tmp[p1 ++];
            } else if (tmp[p1] >= tmp[p2]){
                nums[idx ++] = tmp[p2 ++];
            }
        }
        while (p1 <= mid) {
            ans = (ans+p2-mid-1)%1000000007;
            nums[idx ++] = tmp[p1 ++];
        }
        while (p2 <= hi){
            nums[idx ++] = tmp[p2 ++];
        }
    }
    void mysort(vector<int>& nums, int lo, int hi) {
        if (lo == hi)
            return;
        int mid = lo + (hi-lo)/2;
        mysort(nums, lo, mid);
        mysort(nums, mid+1, hi);
        merge(nums, lo, mid, hi);
    }
    int InversePairs(vector<int>& nums) {
        tmp = vector<int>(nums.size());
        mysort(nums, 0, nums.size()-1);
        return ans;
    }
};
```
