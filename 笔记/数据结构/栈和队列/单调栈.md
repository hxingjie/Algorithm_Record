# 单调栈

## 下一个更大元素I
https://leetcode.cn/problems/next-greater-element-i/
```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 下一个更大元素问题
        // 单调栈: top is minimum
        stack<int> supStack;
        unordered_map<int, int> val2nextVal;
        for (int i = nums2.size()-1; i >= 0; --i) {
            while (! supStack.empty() && nums2[i] >= supStack.top()) {
                supStack.pop();
            }
            val2nextVal[nums2[i]] = supStack.empty() ? -1 : supStack.top();
            supStack.push(nums2[i]);
        }

        vector<int> ans;
        for (int num : nums1) {
            ans.push_back(val2nextVal[num]);
        }
        return ans;
    }
};
```

## 去除重复字母
https://leetcode.cn/problems/remove-duplicate-letters/
```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {
        vector<int> charCnt(26, 0); // 记录每个字符的个数
        for (char c : s) charCnt[c-'a'] += 1;

        vector<bool> inStack(26, false); // 记录栈中是否存在该字符
        stack<char> supStack;

        for (char c : s) {
            charCnt[c-'a'] -= 1;

            if (inStack[c-'a']) continue;
            
            while (! supStack.empty() && supStack.top() > c && charCnt[supStack.top()-'a'] > 0) {
                inStack[supStack.top()-'a'] = false;
                supStack.pop();
            }
            inStack[c-'a'] = true;
            supStack.push(c);
        }
        
        string ans;
        while (! supStack.empty()) {
            ans.push_back(supStack.top());
            supStack.pop();
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```
