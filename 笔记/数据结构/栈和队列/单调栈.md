# 单调栈

## 下一个更大元素I
https://leetcode.cn/problems/next-greater-element-i/
```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // 下一个更大元素问题
        // monotonic stack: stack.top() is nums[i]'s next more greater val
        stack<int> supStack;
        unordered_map<int, int> val2nextVal;
        for (int i = nums2.size()-1; i >= 0; --i) {
            while (! supStack.empty() && nums2[i] >= supStack.top()) {
                supStack.pop();
            }
            val2nextVal[nums2[i]] = supStack.empty() ? -1 : supStack.top();
            supStack.push(nums2[i]);
        }

        vector<int> ans;
        for (int num : nums1) {
            ans.push_back(val2nextVal[num]);
        }
        return ans;
    }
};
```

## 每日温度
https://leetcode.cn/problems/daily-temperatures/
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        // 下一个更大元素问题
        // monotonic stack: stack.top() is nums[i]'s next more greater val
        stack<pair<int, int>> monoStack; // val, idx
        vector<int> ans(temperatures.size(), 0);
        for (int i = temperatures.size()-1; i >= 0; --i) {
            while (! monoStack.empty() && temperatures[i] >= monoStack.top().first) {
                monoStack.pop();
            }

            ans[i] = (monoStack.empty() ? 0 : monoStack.top().second - i);
            monoStack.push(pair<int, int>(temperatures[i], i));
        }
        return ans;
    }
};
```

## 下一个更大元素II
https://leetcode.cn/problems/next-greater-element-ii/description/
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 5 4 2 3 5 4 2
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            nums.push_back(nums[i]);
        }

        stack<int> monoStack;
        vector<int> ans(n, 0);
        for (int i = nums.size()-1; i >= 0; --i) {
            while (! monoStack.empty() && nums[i] >= monoStack.top()) {
                monoStack.pop();
            }
            if (i < n) {
                ans[i] = (monoStack.empty() ? -1 : monoStack.top());
            }
            monoStack.push(nums[i]);
        }
        return ans;
    }
};
```

## 去除重复字母
https://leetcode.cn/problems/remove-duplicate-letters/
```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {
        vector<int> charCnt(26, 0); // 记录每个字符的个数
        for (char c : s) charCnt[c-'a'] += 1;

        vector<bool> inStack(26, false); // 记录栈中是否存在该字符
        stack<char> supStack;

        for (char c : s) {
            charCnt[c-'a'] -= 1;

            if (inStack[c-'a']) continue;
            
            while (! supStack.empty() && supStack.top() > c && charCnt[supStack.top()-'a'] > 0) {
                inStack[supStack.top()-'a'] = false;
                supStack.pop();
            }
            inStack[c-'a'] = true;
            supStack.push(c);
        }
        
        string ans;
        while (! supStack.empty()) {
            ans.push_back(supStack.top());
            supStack.pop();
        }
        reverse(ans.begin(), ans.end());

        return ans;
    }
};
```
