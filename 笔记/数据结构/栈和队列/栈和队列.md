# 栈和队列

## 用栈实现队列
https://leetcode.cn/problems/implement-queue-using-stacks/
```c++
class MyQueue {
public:
    stack<int> inputStack; // 无脑压入输入栈
    stack<int> outputStack; // 输出栈为空，从输入栈取元素
    MyQueue() : inputStack(stack<int>()), outputStack(stack<int>()) {

    }
    
    void push(int x) {
        inputStack.push(x);
    }
    
    int pop() {
        int val = peek(); // outputStack != empty
        outputStack.pop();
        return val;
    }
    
    int peek() {
        if (outputStack.empty()) {
            while (! inputStack.empty()) {
                outputStack.push(inputStack.top());
                inputStack.pop();
            }
        }
        return outputStack.top();
    }
    
    bool empty() {
        return inputStack.empty() && outputStack.empty();
    }
};
```

## 用队列实现栈
https://leetcode.cn/problems/implement-stack-using-queues/
```c++
class MyStack {
public:
    queue<int> q1; // 元素要么在 q1 要么在 q2
    queue<int> q2;
    MyStack() : q1(queue<int>()), q2(queue<int>()) {

    }
    
    void push(int x) {
        if (empty()) {
            q1.push(x);
        } else {
            ! q1.empty() ? q1.push(x) : q2.push(x);
        }
    }
    
    int pop() {
        int val = 0;
        if (! q1.empty()) { // 全部迁入 q2
            while (q1.size() > 1) {
                q2.push(q1.front());
                q1.pop();
            }
            val = q1.front();
            q1.pop();
        } else { // 全部迁入 q1
            while (q2.size() > 1) {
                q1.push(q2.front());
                q2.pop();
            }
            val =  q2.front();
            q2.pop();
        }
        return val;
    }
    
    int top() {
        int val = pop();
        push(val);
        return val;
    }
    
    bool empty() {
        return q1.empty() && q2.empty();
    }
};
```

