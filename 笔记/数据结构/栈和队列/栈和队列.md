# 栈和队列

## 用栈实现队列
https://leetcode.cn/problems/implement-queue-using-stacks/
```c++
class MyQueue {
public:
    stack<int> inputStack; // 无脑压入输入栈
    stack<int> outputStack; // 输出栈为空，从输入栈取元素
    MyQueue() : inputStack(stack<int>()), outputStack(stack<int>()) {

    }
    
    void push(int x) {
        inputStack.push(x);
    }
    
    int pop() {
        int val = peek(); // outputStack != empty
        outputStack.pop();
        return val;
    }
    
    int peek() {
        if (outputStack.empty()) {
            while (! inputStack.empty()) {
                outputStack.push(inputStack.top());
                inputStack.pop();
            }
        }
        return outputStack.top();
    }
    
    bool empty() {
        return inputStack.empty() && outputStack.empty();
    }
};
```

## 用队列实现栈
https://leetcode.cn/problems/implement-stack-using-queues/
```c++
class MyStack {
public:
    queue<int> q1; // 元素要么在 q1 要么在 q2
    queue<int> q2;
    MyStack() : q1(queue<int>()), q2(queue<int>()) {

    }
    
    void push(int x) {
        if (empty()) {
            q1.push(x);
        } else {
            ! q1.empty() ? q1.push(x) : q2.push(x);
        }
    }
    
    int pop() {
        int val = 0;
        if (! q1.empty()) { // 全部迁入 q2
            while (q1.size() > 1) {
                q2.push(q1.front());
                q1.pop();
            }
            val = q1.front();
            q1.pop();
        } else { // 全部迁入 q1
            while (q2.size() > 1) {
                q1.push(q2.front());
                q2.pop();
            }
            val =  q2.front();
            q2.pop();
        }
        return val;
    }
    
    int top() {
        int val = pop();
        push(val);
        return val;
    }
    
    bool empty() {
        return q1.empty() && q2.empty();
    }
};
```

## 单调栈



## 单调队列

主要解决滑动窗口的问题，既要在给定的窗口大小中快速的到新的目标值，又要保持元素进出队列的顺序
需要使用单调队列，保持先进先出的顺序 和 队列中的元素有序

### 滑动窗口的最大值
https://leetcode.cn/problems/sliding-window-maximum/
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq; // front -> back: max -> min
        vector<int> ans;
        for (int i = 0; i < nums.size(); ++i) {
            while (! dq.empty() && nums[i] > dq.back()) {
                dq.pop_back();
            }
            dq.push_back(nums[i]);
            if (i < k-1)
                continue;

            ans.push_back(dq.front());
            if (dq.front() == nums[i-k+1]) {
                dq.pop_front();
            }
        }
        return ans;
    }
};
```

