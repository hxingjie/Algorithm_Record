# 树

## 扁平化嵌套列表迭代器
https://leetcode.cn/problems/flatten-nested-list-iterator/description/
```c++
class NestedIterator {
public:
    int idx;
    vector<int> ans;
    NestedIterator(vector<NestedInteger> &nestedList)
        : idx(0), ans(vector<int>()) {
        GetNums(nestedList, 0);
    }

    void GetNums(vector<NestedInteger> &nestedList, int beg) {
        if (beg >= nestedList.size())
            return;

        if (nestedList[beg].isInteger()) {
            ans.push_back(nestedList[beg].getInteger());
            GetNums(nestedList, beg+1);
        } else {
            vector<NestedInteger> begList = nestedList[beg].getList();
            GetNums(begList, 0);
            GetNums(nestedList, beg+1);
        }
    } 
    
    int next() {
        int res = ans[idx];
        idx += 1;
        return res;
    }
    
    bool hasNext() {
        return idx < ans.size();
    }
};
```

```c++
class NestedIterator {
public:
    int idx;
    vector<int> ans;
    NestedIterator(vector<NestedInteger> &nestedList)
        : idx(0), ans(vector<int>()) {
        for (int i = 0; i < nestedList.size(); ++i) {
            traverse(nestedList[i]);
        }
    }

    void traverse(NestedInteger &root) {
        if (root.isInteger()) {
            ans.push_back(root.getInteger());
            return;
        }
        vector<NestedInteger> childList = root.getList();
        for (int i = 0; i < childList.size(); ++i) {
            traverse(childList[i]);
        }
    }
    
    int next() {
        int res = ans[idx];
        idx += 1;
        return res;
    }
    
    bool hasNext() {
        return idx < ans.size();
    }
};
```

