# 二叉树

## 纲领篇

### 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/552903780/
```c++
// 分解的思路
class Solution {
public:
    int GetMaxDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;

        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
    int maxDepth(TreeNode* root) {
        return GetMaxDepth(root);
    }
};
```

```c++
// 遍历的思路
class Solution {
public:
    int depth;
    int ans;
    void Traverse(TreeNode* root) {
        if (root == nullptr)
            return;

        depth += 1;

        if (root->left == nullptr && root->right == nullptr)
            ans = max(ans, depth);
        Traverse(root->left);
        Traverse(root->right);
        
        depth -= 1;
    }
    int maxDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        depth = 0;
        ans = 0;
        Traverse(root);
        return ans;
    }
};
```

### 二叉树的直径
https://leetcode.cn/problems/diameter-of-binary-tree/
```c++
class Solution {
public:
    int ans;
    int MaxDepth(TreeNode* root) {
        if (! root)
            return 0;

        int leftDepth = MaxDepth(root->left);
        int rightDepth = MaxDepth(root->right);
        ans = max(ans, leftDepth+rightDepth);
        return 1 + max(leftDepth, rightDepth);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 0;
        MaxDepth(root);
        return ans;
    }
};
```

## 思路篇

### 翻转二叉树
https://leetcode.cn/problems/invert-binary-tree/submissions/553177213/
```c++
class Solution {
public:
    TreeNode* Invert(TreeNode* root) {
        if (! root)
            return nullptr;

        TreeNode *tmp = Invert(root->left);
        root->left = Invert(root->right);
        root->right = tmp;

        return root;
    }
    TreeNode* invertTree(TreeNode* root) {
        return Invert(root);
    }
};
```

### 填充每个节点的下一个右侧节点指针
https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/
```c++
class Solution {
public:
    Node* connect(Node* root) {
        if (! root) return nullptr;

        queue<Node*> q;
        q.push(root);

        while (! q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                Node *cur = q.front();
                q.pop();
                cur->next = i == sz-1 ? nullptr : q.front();

                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
        }

        return root;
    }
};
```

### 二叉树展开为链表
https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/
```c++
class Solution {
public:
    TreeNode* FlattenList(TreeNode* root) {
        if (! root) return nullptr;

        TreeNode* left = FlattenList(root->left);
        TreeNode* right = FlattenList(root->right);
        if (left) {
            root->left = nullptr;
            root->right = left;

            TreeNode* p = left;
            while (p->right)
                p = p->right;
            p->right = right;
        } else {
            root->left = nullptr;
            root->right = right;
        }
        return root;
    }
    void flatten(TreeNode* root) {
        FlattenList(root);
        return;
    }
};
```

