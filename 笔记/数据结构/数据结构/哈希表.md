# 哈希表

## 两数之和
https://leetcode.cn/problems/two-sum/
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> num2idx;
        vector<int> ans(2, -1);
        for (int i = 0; i < nums.size(); ++i) {
            if (num2idx.find(target-nums[i]) != num2idx.end()) {
                ans[0] = num2idx[target-nums[i]];
                ans[1] = i;
            } else {
                num2idx[nums[i]] = i;
            }
        }
        return ans;
    }
};
```

## 随机链表的复制
https://leetcode.cn/problems/copy-list-with-random-pointer/
```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (! head)
            return nullptr;

        unordered_map<Node*, int> addr2idx; // for src list
        unordered_map<int, Node*> idx2addr; // for new list
        Node* dummy = new Node(-1, head, nullptr);
        Node* dummy_n = new Node(-1, nullptr, nullptr);
        
        int idx = 0;
        Node* p1 = dummy->next;
        Node* p2 = dummy_n;
        while (p1) { // 第一遍遍历，复制
            Node* cur = new Node(p1->val, nullptr, nullptr);
            p2->next = cur;

            addr2idx[p1] = idx;
            idx2addr[idx] = cur;
            idx += 1;

            p2 = p2->next;
            p1 = p1->next;
        }

        p1 = dummy->next;
        p2 = dummy_n->next;
        while (p1) { // 第一遍遍历，构造
            if (! p1->random) {
                p2->random = nullptr;
            } else {
                int randomIdx = addr2idx[p1->random];
                p2->random = idx2addr[randomIdx];
            }
            p2 = p2->next;
            p1 = p1->next;
        }

        return dummy_n->next;
    }
};
```

## 有效字母的异位词
https://leetcode.cn/problems/valid-anagram/
```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())
            return false;

        vector<int> cnt_s(26, 0);
        vector<int> cnt_t(26, 0);

        for (int i = 0; i < s.size(); ++i) {
            cnt_s[s[i]-'a'] += 1;
            cnt_t[t[i]-'a'] += 1;
        }

        for (int i = 0; i < 26; ++i) {
            if (cnt_s[i] != cnt_t[i])
                return false;
        }

        return true;
    }
};
```

