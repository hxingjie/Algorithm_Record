# 优先级队列

## 合并k个升序链表
https://leetcode.cn/problems/merge-k-sorted-lists/description/
```c++
class Solution {
public:
    class MyCmp {
    public:
        bool operator()(const ListNode* lhs, const ListNode* rhs) const {
            if (lhs->val > rhs->val) {
                return true;
            } else {
                return false;
            }
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, MyCmp> pq;
        for (int i = 0; i < lists.size(); ++i)
            if (lists[i] != nullptr) // 保证队列中元素不为空
                pq.push(lists[i]);
        
        if (pq.empty()) return nullptr;

        ListNode* dummy = new ListNode(-1, nullptr);
        ListNode* p = dummy;
        while (! pq.empty()) {
            ListNode* cur = pq.top();
            pq.pop();

            p->next = cur;
            p = p->next;
            if (cur->next) { // 保证队列中元素不为空
                pq.push(cur->next);
            }
        }
        return dummy->next;
    }
};
```

https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked
```c++
class MedianFinder {
public:
    class ForMax {
    public:
        bool operator() (const int &lhs, const int &rhs) {
            return lhs < rhs;
        }
    };
    class ForMin {
    public:
        bool operator() (const int &lhs, const int &rhs) {
            return lhs > rhs;
        }
    };
    priority_queue<int, vector<int>, ForMax> pq_max; // 大根堆放较小数
    priority_queue<int, vector<int>, ForMin> pq_min; // 小根堆放较大数
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (pq_min.empty() || num <= pq_min.top())
            pq_max.push(num);
        else if (num > pq_min.top())
            pq_min.push(num);

        if (pq_max.size() > pq_min.size()+1) {
            pq_min.push(pq_max.top());
            pq_max.pop();
        } else if (pq_max.size() < pq_min.size()) {
            pq_max.push(pq_min.top());
            pq_min.pop();
        }
    }
    
    double findMedian() {
        if (pq_max.size() == pq_min.size())
            return (pq_max.top()+pq_min.top())/2.0;
        else
            return pq_max.top();
    }
};
```

