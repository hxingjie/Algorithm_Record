# 优先级队列

## 合并有序序列

### 合并k个升序链表
https://leetcode.cn/problems/merge-k-sorted-lists/description/
```c++
class Solution {
public:
    class MyCmp {
    public:
        bool operator()(const ListNode* lhs, const ListNode* rhs) const {
            if (lhs->val > rhs->val) {
                return true;
            } else {
                return false;
            }
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>, MyCmp> pq;
        for (int i = 0; i < lists.size(); ++i)
            if (lists[i] != nullptr) // 保证队列中元素不为空
                pq.push(lists[i]);
        
        if (pq.empty()) return nullptr;

        ListNode* dummy = new ListNode(-1, nullptr);
        ListNode* p = dummy;
        while (! pq.empty()) {
            ListNode* cur = pq.top();
            pq.pop();

            p->next = cur;
            p = p->next;
            if (cur->next) { // 保证队列中元素不为空
                pq.push(cur->next);
            }
        }
        return dummy->next;
    }
};
```

### 查找和最小的k对数字
https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/
```c++
class Solution {
public:
    class Node {
    public:
        int num1, num2, idx, sum;
        Node(int n1, int n2, int i) : num1(n1), num2(n2), idx(i) {
            sum = n1 + n2;
        }
        bool operator<(const Node &rhs) const {
            return sum > rhs.sum;
        }
    };
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        // [1, 7, 11], [2, 4, 6]
        // 1,2 -> 1,4 -> 1,6
        // 7,2 -> 7,4 -> 7,6
        // 11,2 -> 11,4 -> 11,6
        priority_queue<Node> pq;
        for (int i = 0; i < nums1.size(); ++i)
            pq.push(Node(nums1[i], nums2[0], 0));

        vector<vector<int>> ans;
        while (ans.size() < k) {
            Node cur = pq.top();
            pq.pop();
            vector<int> tmp = {cur.num1, cur.num2};
            ans.push_back(tmp);

            if (cur.idx < nums2.size()-1)
                pq.push(Node(cur.num1, nums2[cur.idx+1], cur.idx+1));
        }

        return ans;
    }
};
```

https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked
```c++
class MedianFinder {
public:
    class ForMax {
    public:
        bool operator() (const int &lhs, const int &rhs) {
            return lhs < rhs;
        }
    };
    class ForMin {
    public:
        bool operator() (const int &lhs, const int &rhs) {
            return lhs > rhs;
        }
    };
    priority_queue<int, vector<int>, ForMax> pq_max; // 大根堆放较小数
    priority_queue<int, vector<int>, ForMin> pq_min; // 小根堆放较大数
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (pq_min.empty() || num <= pq_min.top())
            pq_max.push(num);
        else if (num > pq_min.top())
            pq_min.push(num);

        if (pq_max.size() > pq_min.size()+1) {
            pq_min.push(pq_max.top());
            pq_max.pop();
        } else if (pq_max.size() < pq_min.size()) {
            pq_max.push(pq_min.top());
            pq_min.pop();
        }
    }
    
    double findMedian() {
        if (pq_max.size() == pq_min.size())
            return (pq_max.top()+pq_min.top())/2.0;
        else
            return pq_max.top();
    }
};
```

### 有序矩阵中第k小的元素
https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/
```c++
class Solution {
public:
    class Node {
    public:
        int row, col, val;
        Node(int r, int c, int v) : row(r), col(c),val(v) {}
        bool operator<(const Node& other) const {
            return val > other.val;
        }
    };
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        // 1   3  5: 1 -> 3 -> 5
        // 6   7 12: 6 -> 7 -> 12
        // 11 14 14: 11 -> 14 -> 14
        int n = matrix.size();
        priority_queue<Node> pq;
        for (int i = 0; i < n; ++i) {
            pq.push(Node(i, 0, matrix[i][0]));
        }
        int idx = 0, ans = 0;
        while (idx < k) {
            Node cur = pq.top();
            pq.pop();
            idx += 1;
            ans = cur.val;
            if (cur.col < n-1)
                pq.push(Node(cur.row, cur.col+1, matrix[cur.row][cur.col+1]));
        }
        return ans;
    }
};
```

### 设计推特
https://leetcode.cn/problems/design-twitter/
```c++
class Twitter {
public:
    class Tweet {
    public:
        int userId, tweetId, time;
        Tweet* nextTweet;
        Tweet(int i1, int i2, int i3) 
            : userId(i1), tweetId(i2), time(i3), nextTweet(nullptr) {}
    };
    class MyCmp {
    public:
        bool operator()(const Tweet* const &lhs, const Tweet* const &rhs) const {
            return lhs->time < rhs->time;
        }
    };
    int globalTime = 0;
    unordered_map<int, Tweet*> tweets; // userId, tweetId
    unordered_map<int, unordered_set<int>> friends; // userId, friends
    Twitter()
        : tweets(unordered_map<int, Tweet*>()), friends(unordered_map<int, unordered_set<int>>()) {
        
    }
    
    void postTweet(int userId, int tweetId) {
        if (tweets.find(userId) == tweets.end()) {
            tweets[userId] = new Tweet(-1, -1, -1);
            friends[userId] = unordered_set<int>();
        }
        globalTime += 1;
        
        Tweet* tweet = new Tweet(userId, tweetId, globalTime);
        tweet->nextTweet = tweets[userId]->nextTweet;
        tweets[userId]->nextTweet = tweet;// 更新tweet列表
    }
    
    vector<int> getNewsFeed(int userId) {
        if (tweets.find(userId) == tweets.end()) {
            tweets[userId] = new Tweet(-1, -1, -1);
            friends[userId] = unordered_set<int>();
        }
        vector<Tweet*> its;
        if (tweets[userId]->nextTweet)
            its.push_back(tweets[userId]->nextTweet);
        for (int friendId : friends[userId]) {
            if (tweets.find(friendId) != tweets.end() && tweets[friendId]->nextTweet)
                its.push_back(tweets[friendId]->nextTweet);
        }

        priority_queue<Tweet*, vector<Tweet*>, MyCmp> pq;
        for (int i = 0; i < its.size(); ++i) {
            pq.push(its[i]);
        }

        vector<int> res;
        while (! pq.empty() && res.size() < 10) {
            Tweet* t = pq.top();
            pq.pop();
            res.push_back(t->tweetId);
            if (t->nextTweet != nullptr)
                pq.push(t->nextTweet);
        }

        return res;
    }
    
    void follow(int followerId, int followeeId) {
        // followerId 关注 followeeId
        if (tweets.find(followerId) == tweets.end()) {
            tweets[followerId] = new Tweet(-1, -1, -1);
            friends[followerId] = unordered_set<int>();
        }
        if (friends[followerId].find(followeeId) != friends[followerId].end())
            return;
        friends[followerId].insert(followeeId);
    }
    
    void unfollow(int followerId, int followeeId) {
        if (tweets.find(followerId) == tweets.end()) {
            tweets[followerId] = new Tweet(-1, -1, -1);
            friends[followerId] = unordered_set<int>();
        }
        friends[followerId].erase(followeeId);
    }
};
```


