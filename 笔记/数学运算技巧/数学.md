## 乘法的结果求模
对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模：
(a * b) % k = (a % k) * (b % k) % k

## 求解a的b次幂
b为奇数: a^b = a * a^(b-1)
b为偶数: a^b = (a^(b/2))^2

## 找二进制中的1
```c++
int k = 1;
while ((tmp & k) == 0)
    k <<= 1;
```

## 位运算
```
原码:
    0 00, 0 01, 0 10, 0 11:  0  1  2  3
    1 01, 1 10, 1 11, 1 00: -1 -2 -3 -4
移位:
    c++中移位不管符号位，直接移位
异或:
    相同数异或为0，0和任何数异或为任何数
```

## 求素数
首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8... 都不可能是素数了。
然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12... 也都不可能是素数了。
```c++
class Solution {
public:
    int countPrimes(int n) {
        vector<bool> isPrime(n, true);

        for (int i = 2; i * i < n; i++){
            if (isPrime[i]){
                for (int j = i * i; j < n; j += i){
                    isPrime[j] = false;
                }
            }
        }

        int cnt = 0;
        for (int i = 2; i < n; i++){
            if (isPrime[i])
                cnt++;
        }

        return cnt;
    }
};
```

## 整数中1出现的次数
```c++
#include <algorithm>
#include <string>
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n) {
        // 1 2 x 4: 12 * 10 + 10
        // x is cur, digit is 10, high is 12, low is 4
        // x == 0,      ans = 12*10: [00, 11]*[0, 9]
        // x == 1,      ans = 12*10 + (4 + 1): [00, 11]*[0, 9] + [0, 4]
        // x == [2, 9], ans = 12*10 + 10: [00, 11]*[0, 9] + [0, 9]
        string num = to_string(n);

        int ans = 0;
        for (int i = 0; i < num.size(); i++) {
            int digit = (int)pow(10, num.size()-i-1);
            int high = i == 0 ? 0 : stoi(num.substr(0, i));
            int low = i == num.size()-1 ? 0 : stoi(num.substr(i+1));
            if (num[i] == '0')
                ans += high*digit;
            else if (num[i] == '1')
                ans += high*digit+low+1;
            else // num[i] == [2, 9]
                ans += high*digit + digit;
        }

        return ans;
    }
};
```




